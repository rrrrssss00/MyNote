Effective C#
第一章：C#语言元素
1：在类中尽量使用属性，而非直接访问的公有变量
即，只通过Get,Set将值暴露在类外，尽量不提供可以直接修改和访问的公有变量
 
2：定义常量以及常量的类型
当程序或类里需要使用到一个不会发生变化的变量，那么将它设置为常量将提交程序性能;这里有两种方式，声明为const或者声明为readonly，前者更高效，但可能会引发编译错误，后者更稳定
 
3：使用is 和as进行类型转换
更高效，且不易出错，也更容易进行异常控制，（as后，如果类型不符将返回null）
 
4：使用条件属性（Conditional）而非#if
控制程序中某些代码只在Debug时运行
 
5：始终提供ToString()重载
 
6：区别值类型以及引用类型
 
7：使用恒定类型，并恰当地使用C#自有的恒定类型
    将一个类的所有值都设置为只读（Readonly），并将所有属性只设置get方法，即可简单地获得一个恒定类型
    C#中，string类型和DateTime类型都是恒定类型，引申一点，在C#中操作String字符串，不要过多地使用string的+，-，concat,touper,tolower等操作，这些操作都会在内存中新建立一个字符串对象，再将运算结果赋过去，比较好的方法是：使用StringBuilder类来操作字符串，这样不会在内存中新建立对象，并且使用String.Compare方法来比较字符串，这样也支持忽略大小写的比较。
    此外，在使用StringBuilder时，其默认的Buffer大小为16，字条串超出这个大小时，会为其申请新的空间，这样会导致效率较低，所以在声明时，最好给它赋一个合适大小的初值，以提高效率。
    在判断一个字符串是否为空时，str.Length==0比str == ""更快。
 
8：注意0对于值类型都是有效的
主要是对于枚举类型，注意确保0都对应有一个值，否则容易出错
 
9：明白几个相等运算之间的关系    没看明白
10：明白GetHashCode()的缺陷    没看明白 除了Hashtable和Dictionary之外，别用这个东西就行了
 
11：尽量使用foreach做循环
一般情况下，foreach比for,while循环都优，或至少相等，同时foreach能够直接循环多维数组内部，变长数组进行操作时也不用修改代码，具有一定的优势。
 
12：2010中，多次重载的情况下，尽量使用可选参数
仅能用于4.0
 
13:尽量使用Query代替循环
LINQ,C#3.0+，效率和可维护性
 
第2章 .net资源管理
14：尽量选择对变量进行初始化，而非在构造函数或程序运行过程中对它赋初值
这样效率更高，
 
15：使用静态构造函数初始化类的静态成员
静态构造函数比构造函数先执行
 
16：使用构造函数链
当类有多个构造函数时，尽量采用这样的写法，能够提高运行效率：
public MyClass():this(0,"") {}
public MyClass(int a):this(a,""){}
public MyClass(int a,string b) {//todo}
 
17:使用using和try/finally来做资源清理
作者在这里好像列了一些using不好的地方，还是用try来做吧，把dispose相关的代码都放到finally中来处理
 
18：最小化垃圾，减少GC的工作量
注意变量的作用范围，以及一些恒定变量的使用，尽量减少需要回收的变量
 
19：装箱和拆箱的最小化
尤其是对于值类型和Struct（这个东西现在还有人用吗），注意类型转换时是否会做无用的装箱和拆箱
 
20：实现标准的Dispose模式
实现IDisposable接口，在其中实现Dispose方法，释放所有托管和非托管对象，此外，不要在析构函数里写不是释放对象的代码
 
第3章 用C#表达你的设计，合理使用C#的要素及其特点
21：使用接口，而非类继承
更安全，合理，高效，易于维护
 
22：明确接口实现和虚函数重载的区别 没看明白
 
23：使用委托来实现回调 
更灵活
 
24：使用事件定义对外接口
这个不用多说了。。
 
25：避免返回内部类对象的引用：
就是说，即使设置了只能Get不能Set，也可以通过该引用及其包含的方法来改变这个对象，有四种方法来避免这种情况
    1：值类型：所有的值类型在通过属性访问时，是数据的拷贝，不会影响原数据
    2：恒定类型，例如String，这个也不会对原属性进行修改，因为它是不可修改的
    3：定义接口，不暴露对象，只通过接口提供给外界，通过接口来限制其访问和修改
    4：包装：没看明白
 
26：让你的类型支持序列化 没看明白
 
27：使用IComparable及IComparer来比较对象和实现排序关系
 
28: 避免使用ICloneable接口
值类型不需要实现复制，进行赋值即可，
引用类型要实现这个接口的话，需要仔细设计，因为在这些类的子类中可能会遇到问题
 
29：避免使用类型转换
使用强制类型转换时，会生成临时对象，对程序效率有一定影响，也可能会产生一些潜在的BUG
 
30：只有有更新基类时，才使用new关键字
这里的new关键字是指类继承时使用的函数修饰符
 
31：函数体尽量简短
这跟.net的编译器特性有关，过长的函数编译完成后，执行效率不如多个短小函数之和。
 
32：限制对类的访问
不是所有的类及其内部的属性和方法都需要声明成public,根据程序需要限制对类的访问能够提高效率
 
第5章：和Framework一起工作
33：多用重载少用事件处理器
效率问题
 
34：使用数据绑定
DataBinding
